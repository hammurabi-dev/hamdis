// unit tests for Hampix class

#include <cmath>
#include <cstddef> // for std::size_t
#include <fstream>
#include <gtest/gtest.h>
#include <hampix.h>
#include <hampixp.h>
#include <memory>
#include <vector>

const double cgs_pi = 3.14159265358979;

TEST(Hampix, basic) {
  // init
  Hampix<double> map_dft;
  EXPECT_EQ(map_dft.npix(), 0);

  // dft init with given size + copy + move + index + data
  Hampix<double> map_n(233);
  map_dft = map_n; // copy assign
  EXPECT_EQ(map_dft.npix(), 233);
  for (std::size_t i = 0; i < 233; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), double(0.0));
  }
  Hampix<double> map_cpconstr(map_dft); // copy constr
  EXPECT_EQ(map_cpconstr.npix(), 233);
  for (std::size_t i = 0; i < 233; ++i) {
    EXPECT_EQ(map_cpconstr.index(i), i);
    EXPECT_EQ(map_cpconstr.data(i), double(0.0));
    EXPECT_EQ(map_cpconstr.pointing(i).phi(), double(0.0));
    EXPECT_EQ(map_cpconstr.pointing(i).theta(), double(0.0));
  }
  map_dft = std::move(map_cpconstr); // move assign
  EXPECT_EQ(map_dft.npix(), 233);
  for (std::size_t i = 0; i < 233; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), double(0.0));
  }
  Hampix<double> map_mvconstr(std::move(map_n)); // move constr
  EXPECT_EQ(map_mvconstr.npix(), 233);
  for (std::size_t i = 0; i < 233; ++i) {
    EXPECT_EQ(map_mvconstr.index(i), i);
    EXPECT_EQ(map_mvconstr.data(i), double(0.0));
    EXPECT_EQ(map_mvconstr.pointing(i).phi(), double(0.0));
    EXPECT_EQ(map_mvconstr.pointing(i).theta(), double(0.0));
  }

  // pointing + index
  Hampixp point(0.3 * cgs_pi, 1.7 * cgs_pi);
  map_dft.pointing(23, point);
  map_dft.index(23, 1024);
  EXPECT_EQ(map_dft.index(23), std::size_t(1024));
  EXPECT_NEAR(map_dft.pointing(23).theta(), double(0.3 * cgs_pi), 1.0e-10);
  EXPECT_NEAR(map_dft.pointing(23).phi(), double(1.7 * cgs_pi), 1.0e-10);

  // constant init + print (requires visual inspection)
  Hampix<double> map_print(3, 0.2);
  for (std::size_t i = 0; i < 3; ++i) {
    EXPECT_EQ(map_print.data(i), double(0.2));
  }
  map_print.print();
}

TEST(Hampix, reset) {
  // reset from empty constr
  Hampix<double> map_dft;
  map_dft.reset(2);
  EXPECT_EQ(map_dft.npix(), 2);
  for (std::size_t i = 0; i < 2; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), double(0.0));
  }

  // reset with new Nside
  map_dft.reset(4);
  EXPECT_EQ(map_dft.npix(), 4);
  for (std::size_t i = 0; i < 4; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), double(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), double(0.0));
  }

  // reset data to zero
  map_dft.data(2, 1.0);
  map_dft.reset();
  EXPECT_EQ(map_dft.npix(), 4);
  for (std::size_t i = 0; i < 4; ++i) {
    EXPECT_EQ(map_dft.data(i), double(0));
  }
}

TEST(Hampix, undef) {
  Hampix<double> map_dft(2);
  map_dft.undefine(1);
  EXPECT_EQ(map_dft.data(0), double(0));
  EXPECT_EQ(map_dft.data(1), map_dft.undef);

  std::vector<std::size_t> list{0, 1};
  map_dft.undefine(list);
  EXPECT_EQ(map_dft.data(0), map_dft.undef);
  EXPECT_EQ(map_dft.data(1), map_dft.undef);
}

TEST(Healmpix, basic) {
  // init
  Healmpix<double> map_dft;
  EXPECT_EQ(map_dft.npix(), 0);

  // constant init
  Healmpix<double> map_n(2);
  // nside + npix
  EXPECT_EQ(map_n.nside(), 2);
  EXPECT_EQ(map_n.npix(), 48);
  for (std::size_t i = 0; i < 48; ++i) {
    EXPECT_EQ(map_n.data(i), double(0));
    EXPECT_EQ(map_n.index(i), i);
  }

  // copy + move
  map_dft = map_n; // copy assign
  EXPECT_EQ(map_dft.nside(), 2);
  EXPECT_EQ(map_dft.npix(), 48);
  for (std::size_t i = 0; i < 48; ++i) {
    EXPECT_EQ(map_dft.data(i), double(0));
    EXPECT_EQ(map_dft.index(i), i);
  }
  Healmpix<double> map_cpconstr(map_dft); // copy constr
  EXPECT_EQ(map_cpconstr.nside(), 2);
  EXPECT_EQ(map_cpconstr.npix(), 48);
  for (std::size_t i = 0; i < 48; ++i) {
    EXPECT_EQ(map_cpconstr.data(i), double(0));
    EXPECT_EQ(map_cpconstr.index(i), i);
  }
  map_dft = std::move(map_cpconstr); // move assign
  EXPECT_EQ(map_dft.nside(), 2);
  EXPECT_EQ(map_dft.npix(), 48);
  for (std::size_t i = 0; i < 48; ++i) {
    EXPECT_EQ(map_dft.data(i), double(0));
    EXPECT_EQ(map_dft.index(i), i);
  }
  Healmpix<double> map_mvconstr(std::move(map_dft)); // move constr
  EXPECT_EQ(map_mvconstr.nside(), 2);
  EXPECT_EQ(map_mvconstr.npix(), 48);
  for (std::size_t i = 0; i < 48; ++i) {
    EXPECT_EQ(map_mvconstr.data(i), double(0));
    EXPECT_EQ(map_mvconstr.index(i), i);
  }

  // pointing calculation check with HEALPix Nside 2-32
  // reference pointing values are generated by healpy
  Healmpix<double> map_npower1(2);
  std::fstream infile1("reference/pointing_healpix_npower1.bin",
                       std::ios::in | std::ios::binary);
  if (infile1.is_open()) {
    for (std::size_t i = 0; i != map_npower1.npix(); ++i) {
      double tmp;
      // theta
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower1.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower1.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile1.close();
  }
  Healmpix<double> map_npower2(4);
  std::fstream infile2("reference/pointing_healpix_npower2.bin",
                       std::ios::in | std::ios::binary);
  if (infile2.is_open()) {
    for (std::size_t i = 0; i != map_npower2.npix(); ++i) {
      double tmp;
      // theta
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower2.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower2.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile2.close();
  }
  Healmpix<double> map_npower3(8);
  std::fstream infile3("reference/pointing_healpix_npower3.bin",
                       std::ios::in | std::ios::binary);
  if (infile3.is_open()) {
    for (std::size_t i = 0; i != map_npower3.npix(); ++i) {
      double tmp;
      // theta
      infile3.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower3.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile3.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower3.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile3.close();
  }
  Healmpix<double> map_npower4(16);
  std::fstream infile4("reference/pointing_healpix_npower4.bin",
                       std::ios::in | std::ios::binary);
  if (infile4.is_open()) {
    for (std::size_t i = 0; i != map_npower4.npix(); ++i) {
      double tmp;
      // theta
      infile4.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower4.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile4.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower4.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile4.close();
  }
  Healmpix<double> map_npower5(32);
  std::fstream infile5("reference/pointing_healpix_npower5.bin",
                       std::ios::in | std::ios::binary);
  if (infile5.is_open()) {
    for (std::size_t i = 0; i != map_npower5.npix(); ++i) {
      double tmp;
      // theta
      infile5.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower5.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile5.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_npower5.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile5.close();
  }
}

TEST(Healmpix, reset) {
  // reset from empty constr
  Healmpix<double> map_dft;
  map_dft.reset(2);
  EXPECT_EQ(map_dft.nside(), 2);
  EXPECT_EQ(map_dft.npix(), 48);
  std::fstream infile1("reference/pointing_healpix_npower1.bin",
                       std::ios::in | std::ios::binary);
  if (infile1.is_open()) {
    for (std::size_t i = 0; i != map_dft.npix(); ++i) {
      double tmp;
      // theta
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_dft.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_dft.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile1.close();
  }

  // reset with new Nside
  map_dft.reset(4);
  EXPECT_EQ(map_dft.nside(), 4);
  EXPECT_EQ(map_dft.npix(), 192);
  std::fstream infile2("reference/pointing_healpix_npower2.bin",
                       std::ios::in | std::ios::binary);
  if (infile2.is_open()) {
    for (std::size_t i = 0; i != map_dft.npix(); ++i) {
      double tmp;
      // theta
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_dft.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      EXPECT_NEAR(map_dft.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile2.close();
  }

  // reset data to zero
  map_dft.data(2, 1.0);
  map_dft.reset();
  EXPECT_EQ(map_dft.nside(), 4);
  EXPECT_EQ(map_dft.npix(), 192);
  for (std::size_t i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), double(0));
  }
}

TEST(Healmpix, undef) {
  Healmpix<double> map_dft(2);
  map_dft.undefine(1);
  EXPECT_EQ(map_dft.data(1), map_dft.undef);

  std::vector<std::size_t> list{0, 5};
  map_dft.undefine(list);
  EXPECT_EQ(map_dft.data(0), map_dft.undef);
  EXPECT_EQ(map_dft.data(1), map_dft.undef);
  EXPECT_EQ(map_dft.data(5), map_dft.undef);
}

TEST(Healmpix, accumulate) {
  // equal resolution
  Healmpix<double> map_dft(4);
  Healmpix<double> map_add(4, 1.0);
  map_dft.accumulate(map_add);
  for (std::size_t i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), double(1.0));
  }

  // different resolution
  Healmpix<double> map_addlower(2, 2.0);
  map_dft.accumulate(map_addlower);
  for (std::size_t i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), double(3.0));
  }

  Healmpix<double> map_addhigher(8, 2.0);
  map_dft.accumulate(map_addhigher);
  for (std::size_t i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), double(5.0));
  }
}

TEST(Healmpix, interpolation) {
  // import reference
  std::size_t base_npix = 192; // nside 4
  std::size_t high_npix = 768; // nside 8
  std::size_t low_npix = 48;   // nside 2
  std::vector<double> base_input, high_input, low_input;
  std::fstream base_file("reference/random_map_nside4.bin",
                         std::ios::in | std::ios::binary);
  if (base_file.is_open()) {
    for (std::size_t i = 0; i != base_npix; ++i) {
      double tmp;
      base_file.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      base_input.push_back(tmp);
    }
    base_file.close();
  }
  Healmpix<double> base_map(4, base_input);
  std::fstream low_file("reference/random_map_nside2.bin",
                        std::ios::in | std::ios::binary);
  if (low_file.is_open()) {
    for (std::size_t i = 0; i != low_npix; ++i) {
      double tmp;
      low_file.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      low_input.push_back(tmp);
    }
    low_file.close();
  }
  Healmpix<double> low_map(2, low_input);
  std::fstream high_file("reference/random_map_nside8.bin",
                         std::ios::in | std::ios::binary);
  if (high_file.is_open()) {
    for (std::size_t i = 0; i != high_npix; ++i) {
      double tmp;
      high_file.read(reinterpret_cast<char *>(&tmp), sizeof(double));
      high_input.push_back(tmp);
    }
    high_file.close();
  }
  Healmpix<double> high_map(8, high_input);
  // test interpolation
  Healmpix<double> low_test(2);
  low_test.accumulate(base_map);
  Healmpix<double> high_test(8);
  high_test.accumulate(base_map);
  for (std::size_t i = 0; i < low_npix; ++i) {
    EXPECT_NEAR(low_test.data(i), low_map.data(i), 1.0e-10);
  }
  for (std::size_t i = 0; i < high_npix; ++i) {
    EXPECT_NEAR(high_test.data(i), high_map.data(i), 1.0e-10);
  }
}
