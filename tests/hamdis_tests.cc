// unit tests for Hamdis class

#include <fstream>
#include <gtest/gtest.h>
#include <vector>

#include <hamdis.h>
#include <hamp.h>
#include <hamtype.h>
#include <hamunits.h>

TEST(Hamdis, basic) {
  // init
  Hamdis<ham_float> map_dft;
  EXPECT_EQ(map_dft.npix(), 0);

  // dft init with given size + copy + move + index + data
  Hamdis<ham_float> map_n(233);
  map_dft = map_n; // copy assign
  EXPECT_EQ(map_dft.npix(), 233);
  for (ham_uint i = 0; i < 233; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), ham_float(0.0));
  }
  Hamdis<ham_float> map_cpconstr(map_dft); // copy constr
  EXPECT_EQ(map_cpconstr.npix(), 233);
  for (ham_uint i = 0; i < 233; ++i) {
    EXPECT_EQ(map_cpconstr.index(i), i);
    EXPECT_EQ(map_cpconstr.data(i), ham_float(0.0));
    EXPECT_EQ(map_cpconstr.pointing(i).phi(), ham_float(0.0));
    EXPECT_EQ(map_cpconstr.pointing(i).theta(), ham_float(0.0));
  }
  map_dft = std::move(map_cpconstr); // move assign
  EXPECT_EQ(map_dft.npix(), 233);
  for (ham_uint i = 0; i < 233; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), ham_float(0.0));
  }
  Hamdis<ham_float> map_mvconstr(std::move(map_n)); // move constr
  EXPECT_EQ(map_mvconstr.npix(), 233);
  for (ham_uint i = 0; i < 233; ++i) {
    EXPECT_EQ(map_mvconstr.index(i), i);
    EXPECT_EQ(map_mvconstr.data(i), ham_float(0.0));
    EXPECT_EQ(map_mvconstr.pointing(i).phi(), ham_float(0.0));
    EXPECT_EQ(map_mvconstr.pointing(i).theta(), ham_float(0.0));
  }

  // pointing + index
  Hamp point(0.3 * cgs::pi, 1.7 * cgs::pi);
  map_dft.pointing(23, point);
  map_dft.index(23, 1024);
  EXPECT_EQ(map_dft.index(23), ham_uint(1024));
  EXPECT_NEAR(map_dft.pointing(23).theta(), ham_float(0.3 * cgs::pi), 1.0e-10);
  EXPECT_NEAR(map_dft.pointing(23).phi(), ham_float(1.7 * cgs::pi), 1.0e-10);

  // constant init + print (requires visual inspection)
  Hamdis<ham_float> map_print(3, 0.2);
  for (ham_uint i = 0; i < 3; ++i) {
    EXPECT_EQ(map_print.data(i), ham_float(0.2));
  }
  map_print.print();
}

TEST(Hamdis, reset) {
  // reset from empty constr
  Hamdis<ham_float> map_dft;
  map_dft.reset(2);
  EXPECT_EQ(map_dft.npix(), 2);
  for (ham_uint i = 0; i < 2; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), ham_float(0.0));
  }

  // reset with new Nside
  map_dft.reset(4);
  EXPECT_EQ(map_dft.npix(), 4);
  for (ham_uint i = 0; i < 4; ++i) {
    EXPECT_EQ(map_dft.index(i), i);
    EXPECT_EQ(map_dft.data(i), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).phi(), ham_float(0.0));
    EXPECT_EQ(map_dft.pointing(i).theta(), ham_float(0.0));
  }

  // reset data to zero
  map_dft.data(2, 1.0);
  map_dft.reset();
  EXPECT_EQ(map_dft.npix(), 4);
  for (ham_uint i = 0; i < 4; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(0));
  }
}

TEST(Hamdis, undef) {
  Hamdis<ham_float> map_dft(2);
  map_dft.undefine(1);
  EXPECT_EQ(map_dft.data(0), ham_float(0));
  EXPECT_EQ(map_dft.data(1), map_dft.undef);

  std::vector<ham_uint> list{0, 1};
  map_dft.undefine(list);
  EXPECT_EQ(map_dft.data(0), map_dft.undef);
  EXPECT_EQ(map_dft.data(1), map_dft.undef);
}

TEST(Hampix, basic) {
  // init
  Hampix<ham_float> map_dft;
  EXPECT_EQ(map_dft.npix(), 0);

  // constant init
  Hampix<ham_float> map_n(2);
  // nside + npix
  EXPECT_EQ(map_n.nside(), 2);
  EXPECT_EQ(map_n.npix(), 48);
  for (ham_uint i = 0; i < 48; ++i) {
    EXPECT_EQ(map_n.data(i), ham_float(0));
    EXPECT_EQ(map_n.index(i), i);
  }

  // copy + move
  map_dft = map_n; // copy assign
  EXPECT_EQ(map_dft.nside(), 2);
  EXPECT_EQ(map_dft.npix(), 48);
  for (ham_uint i = 0; i < 48; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(0));
    EXPECT_EQ(map_dft.index(i), i);
  }
  Hampix<ham_float> map_cpconstr(map_dft); // copy constr
  EXPECT_EQ(map_cpconstr.nside(), 2);
  EXPECT_EQ(map_cpconstr.npix(), 48);
  for (ham_uint i = 0; i < 48; ++i) {
    EXPECT_EQ(map_cpconstr.data(i), ham_float(0));
    EXPECT_EQ(map_cpconstr.index(i), i);
  }
  map_dft = std::move(map_cpconstr); // move assign
  EXPECT_EQ(map_dft.nside(), 2);
  EXPECT_EQ(map_dft.npix(), 48);
  for (ham_uint i = 0; i < 48; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(0));
    EXPECT_EQ(map_dft.index(i), i);
  }
  Hampix<ham_float> map_mvconstr(std::move(map_dft)); // move constr
  EXPECT_EQ(map_mvconstr.nside(), 2);
  EXPECT_EQ(map_mvconstr.npix(), 48);
  for (ham_uint i = 0; i < 48; ++i) {
    EXPECT_EQ(map_mvconstr.data(i), ham_float(0));
    EXPECT_EQ(map_mvconstr.index(i), i);
  }

  // pointing calculation check with HEALPix Nside 2-32
  // reference pointing values are generated by healpy
  Hampix<ham_float> map_nside2(2);
  std::fstream infile1("reference/pointing_healpix_nside2.bin",
                       std::ios::in | std::ios::binary);
  if (infile1.is_open()) {
    for (ham_uint i = 0; i != map_nside2.npix(); ++i) {
      ham_float tmp;
      // theta
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside2.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside2.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile1.close();
  }
  Hampix<ham_float> map_nside4(4);
  std::fstream infile2("reference/pointing_healpix_nside4.bin",
                       std::ios::in | std::ios::binary);
  if (infile2.is_open()) {
    for (ham_uint i = 0; i != map_nside4.npix(); ++i) {
      ham_float tmp;
      // theta
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside4.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside4.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile2.close();
  }
  Hampix<ham_float> map_nside8(8);
  std::fstream infile3("reference/pointing_healpix_nside8.bin",
                       std::ios::in | std::ios::binary);
  if (infile3.is_open()) {
    for (ham_uint i = 0; i != map_nside8.npix(); ++i) {
      ham_float tmp;
      // theta
      infile3.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside8.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile3.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside8.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile3.close();
  }
  Hampix<ham_float> map_nside16(16);
  std::fstream infile4("reference/pointing_healpix_nside16.bin",
                       std::ios::in | std::ios::binary);
  if (infile4.is_open()) {
    for (ham_uint i = 0; i != map_nside16.npix(); ++i) {
      ham_float tmp;
      // theta
      infile4.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside16.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile4.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside16.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile4.close();
  }
  Hampix<ham_float> map_nside32(32);
  std::fstream infile5("reference/pointing_healpix_nside32.bin",
                       std::ios::in | std::ios::binary);
  if (infile5.is_open()) {
    for (ham_uint i = 0; i != map_nside32.npix(); ++i) {
      ham_float tmp;
      // theta
      infile5.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside32.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile5.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_nside32.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile5.close();
  }
}

TEST(Hampix, reset) {
  // reset from empty constr
  Hampix<ham_float> map_dft;
  map_dft.reset(2);
  EXPECT_EQ(map_dft.nside(), 2);
  EXPECT_EQ(map_dft.npix(), 48);
  std::fstream infile1("reference/pointing_healpix_nside2.bin",
                       std::ios::in | std::ios::binary);
  if (infile1.is_open()) {
    for (ham_uint i = 0; i != map_dft.npix(); ++i) {
      ham_float tmp;
      // theta
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_dft.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile1.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_dft.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile1.close();
  }

  // reset with new Nside
  map_dft.reset(4);
  EXPECT_EQ(map_dft.nside(), 4);
  EXPECT_EQ(map_dft.npix(), 192);
  std::fstream infile2("reference/pointing_healpix_nside4.bin",
                       std::ios::in | std::ios::binary);
  if (infile2.is_open()) {
    for (ham_uint i = 0; i != map_dft.npix(); ++i) {
      ham_float tmp;
      // theta
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_dft.pointing(i).theta(), tmp, 1.0e-10);
      // phi
      infile2.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      EXPECT_NEAR(map_dft.pointing(i).phi(), tmp, 1.0e-10);
    }
    infile2.close();
  }

  // reset data to zero
  map_dft.data(2, 1.0);
  map_dft.reset();
  EXPECT_EQ(map_dft.nside(), 4);
  EXPECT_EQ(map_dft.npix(), 192);
  for (ham_uint i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(0));
  }
}

TEST(Hampix, undef) {
  Hampix<ham_float> map_dft(2);
  map_dft.undefine(1);
  EXPECT_EQ(map_dft.data(1), map_dft.undef);

  std::vector<ham_uint> list{0, 5};
  map_dft.undefine(list);
  EXPECT_EQ(map_dft.data(0), map_dft.undef);
  EXPECT_EQ(map_dft.data(1), map_dft.undef);
  EXPECT_EQ(map_dft.data(5), map_dft.undef);
}

TEST(Hampix, accumulate) {
  // equal resolution
  Hampix<ham_float> map_dft(4);
  Hampix<ham_float> map_add(4, 1.0);
  map_dft.accumulate(map_add);
  for (ham_uint i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(1.0));
  }

  // different resolution
  Hampix<ham_float> map_addlower(2, 2.0);
  map_dft.accumulate(map_addlower);
  for (ham_uint i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(3.0));
  }

  Hampix<ham_float> map_addhigher(8, 2.0);
  map_dft.accumulate(map_addhigher);
  for (ham_uint i = 0; i < 192; ++i) {
    EXPECT_EQ(map_dft.data(i), ham_float(5.0));
  }
}

TEST(Hampix, interpolation) {
  // import reference
  ham_uint base_npix = 192; // nside 4
  ham_uint high_npix = 768; // nside 8
  ham_uint low_npix = 48;   // nside 2
  std::vector<ham_float> base_input, high_input, low_input;
  std::fstream base_file("reference/random_map_nside4.bin",
                         std::ios::in | std::ios::binary);
  if (base_file.is_open()) {
    for (ham_uint i = 0; i != base_npix; ++i) {
      ham_float tmp;
      base_file.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      base_input.push_back(tmp);
    }
    base_file.close();
  }
  Hampix<ham_float> base_map(4, base_input);
  std::fstream low_file("reference/random_map_nside2.bin",
                        std::ios::in | std::ios::binary);
  if (low_file.is_open()) {
    for (ham_uint i = 0; i != low_npix; ++i) {
      ham_float tmp;
      low_file.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      low_input.push_back(tmp);
    }
    low_file.close();
  }
  Hampix<ham_float> low_map(2, low_input);
  std::fstream high_file("reference/random_map_nside8.bin",
                         std::ios::in | std::ios::binary);
  if (high_file.is_open()) {
    for (ham_uint i = 0; i != high_npix; ++i) {
      ham_float tmp;
      high_file.read(reinterpret_cast<char *>(&tmp), sizeof(ham_float));
      high_input.push_back(tmp);
    }
    high_file.close();
  }
  Hampix<ham_float> high_map(8, high_input);
  // test interpolation
  Hampix<ham_float> low_test(2);
  low_test.accumulate(base_map);
  Hampix<ham_float> high_test(8);
  high_test.accumulate(base_map);
  for (ham_uint i = 0; i < low_npix; ++i) {
    EXPECT_NEAR(low_test.data(i), low_map.data(i), 1.0e-10);
  }
  for (ham_uint i = 0; i < high_npix; ++i) {
    EXPECT_NEAR(high_test.data(i), high_map.data(i), 1.0e-10);
  }
}
